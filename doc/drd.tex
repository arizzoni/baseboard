\documentclass[12pt, titlepage]{/home/air/projects/latex-template/tex-template}
\newcommand{\theauthor}{Alessandro Rizzoni}
\newcommand{\thedoctitle}{Baseboard Design Reference Document}

% Circuit and Block Diagrams
\usepackage[siunitx]{circuitikz} % Electrical circuit graphics
\ctikzloadstyle{romano} % Better styling for CircuiTikz
\tikzset{romano circuit style} % Apply the style

\begin{document}

\maketitle

\pagebreak
\tableofcontents
\pagebreak

\blankpage

\pagebreak
\begin{revisionhistory}
    Version 1
\end{revisionhistory}
\pagebreak

\blankpage

\pagebreak

\section{Introduction}
The baseboard module contains all the signal and power IO for the effects pedal. Input voltage of \SI{9}{\volt} DC is regulated to 12V to drive an analog switch and the effects board and to \SI{3.3}{\volt} to drive the LED indicators and footswitches. A \SI{16}{\bit} microcontroller manages the switching logic, interfaces with peripherals, and supervises the power supply circuit. The audio input and output are routed to the effects modules via the switching circuitry through a cable.

\section{Specifications}
\begin{enumerate}
    \item Power
          \begin{enumerate}
              \item The Baseboard shall provide a \qtyrange[range-units = single, range-phrase = --]{9}{12}{\volt} \pm 1\% power supply capable of sourcing \pm \SI{50}{\milli\ampere} each to the audio effect modules
              \item The Baseboard shall provide low-voltage power circuitry capable of operation from \SI{1.1}{\volt} \pm 1\% to \SI{3.3}{\volt} \pm 1\%
              \item The Baseboard shall be capable of sourcing \SI{300}{\milli\ampere} peak to drive local peripherals
          \end{enumerate}
          \item{Input/Output}
          \begin{enumerate}
              \item The Baseboard shall route the audio signal to the baseboard while providing a true bypass path directly to the output
              \item The Baseboard shall provide input impedance of \SI{1}{\mega\ohm} \pm 1\% and output impedance of \SI{50}{\kilo\ohm} \pm 1\%
              \item Input Filter
              \item Output Filter
          \end{enumerate}
          \item{Switching}
          \begin{enumerate}
              \item The audio signal shall be switched using high quality analog switches to maximize durability and signal integrity
              \item The switches shall have an input impedance of no greater than \SI{500}{\ohm} to minimize signal degradation
          \end{enumerate}
\end{enumerate}

\section{System Architecture}
\begin{figure}[!ht]
    \tikzset{
        block/.style = {draw, fill=white, rectangle, minimum height=3em, minimum width=3em},
        empty diodes,
    }
    \begin{center}
        \begin{circuitikz}[scale=1, transform shape]
            \draw 
            (0, 0) node [bnc, name=audioin, anchor=zero] (audioin) {\textit{Audio In}}
            ;
            \draw
            (audioin.shield) -- ++(0, -0.25) node [tlground] {}
            ;
            \draw
            (audioin.hot) to[highpass=\textit{Input Filter}] ++(4, 0)
            to[short]++(0, 0)
            node [muxdemux, muxdemux def={Lh=6, Rh=8, NL=3, NR=6, NT=0, NB=3, square pins=1}, anchor=lpin 1] (mux1) {\textit{MUX 1}}
            ;
            \draw
            (mux1.lpin 2) to[short]++(-0.5, 0)
            node [label] (atob) {}
            ;
            \draw
            (mux1.lpin 3) to[short]++(-0.5, 0)
            to[short] (atob.center)
            ;
            \draw
            (mux1.rpin 1) to[short]++(3, 0)
            node [iecplugR, name=] (effect1out) {\textit{Effect 1 Send}}
            ;
            \draw
            (mux1.rpin 2) to[short]++(0.5, 0)
            node [label] (bypass1) {}
            to[open]++(1, 0)
            node [label] (effect1return) {}
            ;
            \draw
            (mux1.rpin 3) to[short]++(0.5, 0)
            to[short] (bypass1.center)
            ;
            \draw
            (mux1.rpin 4) to[short]++(1.5, 0)
            to[short] (effect1return.center)
            to[short] ++(1.5, 0)
            node [iecplugR] (effect1in) {\textit{Effect 1 Return}}
            ;
            \draw
            (mux1.rpin 5) to[short]++(1.5, 0)
            to[short] ++(0, -2.125)
            to[short] ++(1.5, 0)
            node [iecplugR] (effect2out) {\textit{Effect 2 Send}}
            ;
            \draw
            (mux1.rpin 6) to[short]++(0.5, 0)
            node [label] (mux1rpin6) {}
            ;
            \draw
            (mux1.bpin 1) to[short]++(0, 0)
            node [dipchip, num pins=6, hide numbers, no topmark, rotate=90, anchor=pin 6] (micro) {}
            ;
            \draw
            (micro.center) to[open]++(0, 0)
            node [label] (uc) {$\mu C$}
            ;
            \draw
            (micro.pin 1) to[short]++(0, 0)
            node [muxdemux, muxdemux def={Lh=6, Rh=8, NL=3, NR=6, NT=3, NB=0, square pins=1}, anchor=tpin 1] (mux2) {\textit{MUX 2}}
            ;
            \draw
            (mux2.lpin 1) to[short]++(-0.5, 0)
            node [label] (btoc) {}
            ;
            \draw
            (mux2.lpin 2) to[short]++(-0.5, 0)
            to[short] (btoc.center)
            ;
            \draw
            (mux2.rpin 1) to[short]++(0.5, 0)
            to[short] (mux1rpin6.center) {}
            ;
            \draw
            (mux2.rpin 2) to[short]++(1.5, 0)
            to[short] ++(0, 2.125)
            to[short] ++(1.5, 0)
            node [iecplugR] (effect2in) {\textit{Effect 2 Return}}
            ;
            \draw
            (mux2.rpin 5) to[short]++(0.5, 0)
            node [label] (bypass2) {}
            to[open] ++(1, 0)
            node [label] (effect3return) {}
            ;
            \draw
            (mux2.rpin 4) to[short]++(0.5, 0)
            to[short] (bypass2.center)
            ;
            \draw
            (mux2.rpin 6) to[short]++(3, 0)
            node [iecplugR] (effect3in) {\textit{Effect 3 Return}}
            ;
            \draw
            (mux2.rpin 3) to[short]++(1.5, 0)
            to[short] (effect3return.center)
            to[short] ++(1.5, 0)
            node [iecplugR] (effect3out) {\textit{Effect 3 Send}}
            ;
            \draw
            (mux2.lpin 3) to[highpass=\textit{Output Filter}] ++(-4, 0)
            node [bnc, name=audioout, anchor=zero] (audioout) {\textit{Audio Out}}
            ;
            \draw
            (audioout.shield) -- ++(0, -0.25) node [tlground] {}
            ;
        \end{circuitikz}
    \caption{Audio Switching Architecture}
    \end{center}
\end{figure}
\section{Power Supplies}

\subsection{Overview}

\begin{figure}[!ht]
    \tikzset{
        block/.style = {draw, fill=white, rectangle, minimum height=3em, minimum width=3em},
        empty diodes,
    }
    \begin{center}
        \begin{circuitikz}[scale=1, transform shape]
            \draw 
            (0, 0) node [bnc, name=dcinput, anchor=zero, rotate=90, xscale=-1] (dcinput) {}
            to[open] ++(0, 0.5)
            node {\qtyrange[range-units = single, range-phrase = --]{9}{12}{\volt}}
            to[open] ++(0, 0.5)
            node {DC INPUT}
            ;
            \draw
            (dcinput.hot) -- ++(0, -0.25) node [tlground] {}
            ;
            \draw
            (dcinput.shield) to[thR=PTC] ++(4, 0) 
            to[D=Bridge Rectifier] ++(1, 0)
            to[short] ++(1, 0)
            node [circ, name=upper] {}
            to[short] ++(1, 0)
            to[sdcdc=15V DC/DC, blocks dc out segments=3, blocks dc in segments=3] ++(2, 0)
            to[sdcdc=Linear Regulator, blocks dc in segments=3, -o] ++(4, 0)
            node [above, name=12Vout] (12Vout) {\SI{12}{\volt} Rail}
            ;
            \draw
            (upper) to[short] ++(0, -2)
            node [circ, name=lower] {}
            to[short] ++(1, 0)
            to[sdcdc=3.3V DC/DC, blocks dc out segments=1, blocks dc in segments=3] ++(2, 0)
            to[short, -o] ++(4, 0)
            node [above, name=3V3out] (3V3out) {\SI{3.3}{\volt} Rail}
            ;
            \draw
            (0,-2) node [iecsocketR, name=usbvbus] (usbvbus) {}
            ;
            \draw
            (usbvbus) to[open] ++(0, 0.5)
            node {\SI{5}{\volt}}
            to[open] ++(0, 0.5)
            node {USB VBUS}
            ;
            \draw
            (usbvbus.right) to[thR=PTC] ++(4, 0)
            to[sD=Schottky] ++(1, 0)
            to[short] (lower)
            ;
        \end{circuitikz}
    \caption{Power Supply Architecture}
    \end{center}
\end{figure}

Input power is provided from the DC input jack or the USB-C port and is fused with PTC thermistors. A full-bridge rectifier at the DC input jack allows for both center-negative and center-positive connections. Both supplies can be powered by either the DC input at \qtyrange[range-units = single, range-phrase = --]{9}{12}{\volt} or the \SI{5}{\volt} USB VBUS supply, with current OR-ing capability provided by the polarity protection rectifier and a schottky diode in series with the USB VBUS. Following the current OR-ing circuitry and overcurrent protection, the input power flows to the DC/DC converters.

The Baseboard requires two voltage rails: the analog voltage rail at \SI{12}{\volt} and the digital voltage rail at \SI{3.3}{\volt}. The analog voltage rail is powered by the Texas Instruments TPS61170 and the digital rail is powered using a voltage regulator for simplicity. The coupled-inductor SEPIC topology was selected for its low ripple and for its ability to act as both a step-up and step-down converter. The TPS61170 supports the SEPIC topology and has a high, fixed switching frequency of \SI{1.2}{\mega\hertz}, allowing for small surface-mount passives to reduce cost and simplify assembly. The analog supply, at \SI{12}{\volt}, also employs a linear regulator as a filter to further reduce ripple and improve line regulation. The second regulator stage brings the voltage down to the \SI{12}{\volt} required to power the analog rail.

\subsection{Analog Supply}

\begin{pycode}
rng = np.random.default_rng()

ntrials = 100000

L = np.zeros(ntrials)
V_f = np.zeros(ntrials)
f_s = np.zeros(ntrials)
eta = np.zeros(ntrials)
I_lim = np.zeros(ntrials)
V_ref = np.zeros(ntrials)
R_2 = np.zeros(ntrials)
R_1 = np.zeros(ntrials)
R_1_nom = np.zeros(ntrials)
V_out = np.zeros(ntrials)
C_3 = np.zeros(ntrials)
C_2 = np.zeros(ntrials)
R_load = np.zeros(ntrials)
G_ea = np.zeros(ntrials)
R_sense = np.zeros(ntrials)
f_P1 = np.zeros(ntrials)
f_P2 = np.zeros(ntrials)
I_P_5V = np.zeros(ntrials)
I_P_9V = np.zeros(ntrials)
I_P_12V = np.zeros(ntrials)
I_out_5V = np.zeros(ntrials)
I_out_9V = np.zeros(ntrials)
I_out_12V = np.zeros(ntrials)
C_out_5V = np.zeros(ntrials)
C_out_9V = np.zeros(ntrials)
C_out_12V = np.zeros(ntrials)
duty_5V = np.zeros(ntrials)
duty_9V = np.zeros(ntrials)
duty_12V = np.zeros(ntrials)
C_s_5V = np.zeros(ntrials)
C_s_9V = np.zeros(ntrials)
C_s_12V = np.zeros(ntrials)
f_RHPZ_5V = np.zeros(ntrials)
f_RHPZ_9V = np.zeros(ntrials)
f_RHPZ_12V = np.zeros(ntrials)
A_5V = np.zeros(ntrials)
A_9V = np.zeros(ntrials)
A_12V = np.zeros(ntrials)
V_outs = np.zeros(ntrials)

tolerance = '1%'
V_out_nom = 12
R_2_nom = 10e3  # Texas Instruments TPS61170
V_ripple = 0.010  # Target ripple voltage = 25mV

i = 0
while i < ntrials:
    # Eaton DRQ73-100-R
    L[i] = rng.triangular(0.8*10.3e-6, 10.3e-6, 1.2*10.3e-6)

    # Diodes Inc. DFLS240L-7 or DFLS260L-7
    V_f[i] = rng.normal(0.20, 0.05/6)

    # Texas Instruments TPS611705
    f_s[i] = rng.triangular(1e6, 1.25e6, 1.5e6)
    eta[i] = rng.normal(0.85, 0.07/3)
    I_lim[i] = rng.triangular(0.96, 1.2, 1.44)
    V_ref[i] = rng.triangular(1.204, 1.229, 1.254)

    # Design Parameters
    R_2[i] = rng.triangular(0.99*R_2_nom, R_2_nom, 1.01*R_2_nom)
    R_1_nom[i] = find_closest_e_series_number(
        R_2[i] * ((V_out_nom/V_ref[i]) - 1),
        tolerance
        )
    R_1[i] = rng.triangular(0.99*R_1_nom[i], R_1_nom[i], 1.01*R_1_nom[i])
    V_out[i] = V_ref[i]*((R_1[i] / R_2[i]) + 1)

    # Monte Carlo
    V_ins = [5, 9, 12]
    for V_in in V_ins:
        I_P = 1 / (L[i] * f_s[i] * (1 / (V_out[i] + V_f[i] - V_in) + 1 / V_in))
        I_out = V_in * (I_lim[i] - 0.5*I_P) * eta[i] / V_out[i]
        C_out = find_closest_e_series_number(
            ((V_out[i] - V_in) * I_out) / (V_out[i] * f_s[i] * V_ripple),
            tolerance
            )
        duty = (V_out[i] - V_in) / V_out[i]
        C_s = find_closest_e_series_number(
            (I_out * duty) / (f_s[i] * 0.1 * V_in),
            tolerance
            )
        f_RHPZ = (R_load[i] / (2*np.pi*L[i])) * (V_in / V_out[i])**2
        A = 3.687e6*G_ea[i]*R_load[i]*(V_in/(V_out[i]*R_sense[i]))/V_out[i]

        if V_in == 5:
            I_P_5V[i] = I_P
            I_out_5V[i] = I_out
            C_out_5V[i] = C_out
            duty_5V[i] = duty
            C_s_5V[i] = C_s
            f_RHPZ_5V[i] = f_RHPZ
            A_5V[i] = A
        if V_in == 9:
            I_P_9V[i] = I_P
            I_out_9V[i] = I_out
            C_out_9V[i] = C_out
            duty_9V[i] = duty
            C_s_9V[i] = C_s
            f_RHPZ_9V[i] = f_RHPZ
            A_9V[i] = A
        if V_in == 12:
            I_P_12V[i] = I_P
            I_out_12V[i] = I_out
            C_out_12V[i] = C_out
            duty_12V[i] = duty
            C_s_12V[i] = C_s
            f_RHPZ_12V[i] = f_RHPZ
            A_12V[i] = A
    i = i + 1

R_1_value = find_closest_e_series_number(np.mean(R_1_nom), tolerance)

C_out_value = find_closest_e_series_number(
    np.nanmax(np.concatenate((C_out_5V, C_out_9V, C_out_12V))),
    tolerance
    )
C_s_value = find_closest_e_series_number(
    np.nanmax(np.concatenate((C_s_5V, C_s_9V, C_s_12V))),
    tolerance
    )

fig, ax = plt.subplots(3, 1)
ax[0].hist(I_out_5V, bins='auto', label=r"$I_{out}(V_{in}=\SI{5}{\volt})$")
ax[1].hist(I_out_9V, bins='auto', label=r"$I_{out}(V_{in}=\SI{9}{\volt})$")
ax[2].hist(I_out_12V, bins='auto', label=r"$I_{out}(V_{in}\SI{12}{\volt})$")
ax[0].xaxis.set_major_formatter(eng_format(r'\unit{\ampere}'))
ax[1].xaxis.set_major_formatter(eng_format(r'\unit{\ampere}'))
ax[2].xaxis.set_major_formatter(eng_format(r'\unit{\ampere}'))
ax[0].legend(loc='upper left')
ax[1].legend(loc='upper left')
ax[2].legend(loc='upper left')
ax[1].set_ylabel(r'Count $\left(1\right)$')
ax[2].set_xlabel(r'Output Current $\left(\unit{\ampere}\right)$')
save_pythontex_figure(fig, 'psu_i_out_monte_carlo')

fig, ax=plt.subplots(3, 1)
ax[0].hist(I_out_5V, bins='auto', density=True, cumulative=True,
           label=r"$I_{out}(V_{in}=\SI{5}{\volt})$"
           )
ax[1].hist(I_out_9V, bins='auto', density=True, cumulative=True,
           label=r"$I_{out}(V_{in}=\SI{9}{\volt})$"
           )
ax[2].hist(I_out_12V, bins='auto', density=True, cumulative=True,
           label=r"$I_{out}(V_{in}\SI{12}{\volt})$"
           )
ax[0].xaxis.set_major_formatter(eng_format(r'\unit{\ampere}'))
ax[1].xaxis.set_major_formatter(eng_format(r'\unit{\ampere}'))
ax[2].xaxis.set_major_formatter(eng_format(r'\unit{\ampere}'))
ax[0].legend(loc='upper left')
ax[1].legend(loc='upper left')
ax[2].legend(loc='upper left')
ax[1].set_ylabel(r'$P\left(I_{out} \leq I_{out_0}\right)$')
ax[2].set_xlabel(r'Output Current $\left(\unit{\ampere}\right)$')
save_pythontex_figure(fig, 'psu_i_out_monte_carlo_cum')

fig, ax=plt.subplots(1, 1)
ax.hist(V_out, bins='auto', label=r"$V_{out}$")
ax.xaxis.set_major_formatter(eng_format(r'\unit{\volt}'))
ax.set_ylabel(r'Count $\left(1\right)$')
ax.set_xlabel(r'Output Voltage $\left(\unit{\volt}\right)$')
save_pythontex_figure(fig, 'psu_v_out_monte_carlo')

fig, ax=plt.subplots(1, 1)
ax.hist(V_out, bins='auto', density=True, cumulative=True, label=r"$V_{out}$")
ax.xaxis.set_major_formatter(eng_format(r'\unit{\volt}'))
ax.set_ylabel(r'$P\left(V_{out} \leq V_{out_0}\right)$')
ax.set_xlabel(r'Output Voltage $\left(\unit{\volt}\right)$')
save_pythontex_figure(fig, 'psu_v_out_monte_carlo_cum')

fig, ax=plt.subplots(3, 1)
ax[0].hist(C_out_5V, bins='auto', label=r"$C_{out}(V_{in}=\SI{5}{\volt})$")
ax[1].hist(C_out_9V, bins='auto', label=r"$C_{out}(V_{in}=\SI{9}{\volt})$")
ax[2].hist(C_out_12V, bins='auto', label=r"$C_{out}(V_{in}\SI{12}{\volt})$")
ax[0].xaxis.set_major_formatter(eng_format(r'\unit{\farad}'))
ax[1].xaxis.set_major_formatter(eng_format(r'\unit{\farad}'))
ax[2].xaxis.set_major_formatter(eng_format(r'\unit{\farad}'))
ax[0].legend(loc='upper left')
ax[1].legend(loc='upper left')
ax[2].legend(loc='upper left')
ax[1].set_ylabel(r'Count $\left(1\right)$')
ax[2].set_xlabel(r'Output Capacitor Size $\left(\unit{\farad}\right)$')
save_pythontex_figure(fig, 'psu_c_out_monte_carlo')

fig, ax=plt.subplots(3, 1)
ax[0].hist(C_out_5V, bins='auto', density=True, cumulative=True,
           label=r"$C_{out}(V_{in}=\SI{5}{\volt})$"
           )
ax[1].hist(C_out_9V, bins='auto', density=True, cumulative=True,
           label=r"$C_{out}(V_{in}=\SI{9}{\volt})$"
           )
ax[2].hist(C_out_12V, bins='auto', density=True, cumulative=True,
           label=r"$C_{out}(V_{in}\SI{12}{\volt})$"
           )
ax[0].xaxis.set_major_formatter(eng_format(r'\unit{\farad}'))
ax[1].xaxis.set_major_formatter(eng_format(r'\unit{\farad}'))
ax[2].xaxis.set_major_formatter(eng_format(r'\unit{\farad}'))
ax[0].legend(loc='upper left')
ax[1].legend(loc='upper left')
ax[2].legend(loc='upper left')
ax[1].set_ylabel(r'$P\left(C_{out} \leq C_{out_0}\right)$')
ax[2].set_xlabel(r'Output Capacitor Size $\left(\unit{\farad}\right)$')
save_pythontex_figure(fig, 'psu_c_out_monte_carlo_cum')

fig, ax=plt.subplots(3, 1)
ax[0].hist(C_s_5V, bins='auto', label=r"$C_{s}(V_{in}=5V)$")
ax[1].hist(C_s_9V, bins='auto', label=r"$C_{s}(V_{in}=9V)$")
ax[2].hist(C_s_12V, bins='auto', label=r"$C_{s}(V_{in}=12V)$")
ax[0].xaxis.set_major_formatter(eng_format(r'\unit{\farad}'))
ax[1].xaxis.set_major_formatter(eng_format(r'\unit{\farad}'))
ax[2].xaxis.set_major_formatter(eng_format(r'\unit{\farad}'))
ax[0].legend(loc='upper left')
ax[1].legend(loc='upper left')
ax[2].legend(loc='upper left')
ax[1].set_ylabel(r'Count $\left(1\right)$')
ax[2].set_xlabel(r'Coupling Capacitor Size $\left(\unit{\farad}\right)$')
save_pythontex_figure(fig, 'psu_c_s_monte_carlo')

fig, ax=plt.subplots(3, 1)
ax[0].hist(C_s_5V, bins='auto', density=True, cumulative=True,
           label=r"$C_{s}(V_{in}=5V)$"
           )
ax[1].hist(C_s_9V, bins='auto', density=True, cumulative=True,
           label=r"$C_{s}(V_{in}=9V)$"
           )
ax[2].hist(C_s_12V, bins='auto', density=True, cumulative=True,
           label=r"$C_{s}(V_{in}=12V)$"
           )
ax[0].xaxis.set_major_formatter(eng_format(r'\unit{\farad}'))
ax[1].xaxis.set_major_formatter(eng_format(r'\unit{\farad}'))
ax[2].xaxis.set_major_formatter(eng_format(r'\unit{\farad}'))
ax[0].legend(loc='upper left')
ax[1].legend(loc='upper left')
ax[2].legend(loc='upper left')
ax[1].set_ylabel(r'$P\left(C_s \leq C_{s_0}\right)$')
ax[2].set_xlabel(r'Coupling Capacitor Size $\left(\unit{\farad}\right)$')
save_pythontex_figure(fig, 'psu_c_s_monte_carlo_cum')

\end{pycode}

\subsubsection{Inductor}
The design for the analog DC/DC converter begins with inductor selection. Output current capacity is largely determined by the inductor size. For this design, a small inductor is sufficient as the amount of current required by the effects is generally small. A standard compact coupled inductor with series inductance of \SI{22}{\micro\henry} and parallel inductance of \SI{11}{\micro\henry} is predicted to be sufficient to drive loads at up to \SI{80}{\milli\ampere} per effects module, worst-case, by the following Monte Carlo analysis with parameters extracted from the relevant component's datasheets and with three modules. The analysis was performed for the three specified input voltages: \SI{5}{\volt}, \SI{9}{\volt}, and \SI{12}{\volt}. Based on the analysis, the supply is able to safely drive \SI{200}{\milli\ampere} per effects module if powered from a \SI{12}{\volt} input, which allows for future expansion using this design.

\begin{figure}[!ht]
    \centering
    \input{figures/pgf/psu_i_out_monte_carlo.pgf}
    \input{figures/pgf/psu_i_out_monte_carlo_cum.pgf}
    \caption{Power Supply Maximum Output Current}
\end{figure}

The analysis begins by assuming each parameter may be described by a probability distribution function and assigning a reasonable function to each. For the majority of datasheet parameters, the manufacturer only provides three values: an upper bound, a lower bound, and a nominal value - we assume that these datasheet parameters have a triangular PDF based on the given bounds and value for the purpose of this analysis but this may very well not be the case depending on the available components.

\subsubsection{Feedback Network}
The output voltage of the converter is determined by the following expression.

$$ V_{out} = V_{ref} \left(\frac{R_1}{R_2} + 1 \right) $$

 The output voltage is a function of $R_1$ and $R_2$, and their tolerances determine the precision of the output voltage. The minimum possible output voltage, assuming all parts are within specifications, is \SI{13.2}{\volt}, so the values shall be chosen to yield an output above that so that \SI{14}{\volt} is beyond the lower tail of the output distribution. The value for $V_{ref}$ comes from the datasheet and is the internal feedback reference voltage of the TPS61170. The values chosen for the feedback resistors are below; a $1\%$ tolerance was chosen as the standard design tolerance to reduce variation.

$$ R_1 = \py{r'\SI{%s}{%s}' % (signif(R_1_value/1000, 3), r'\kilo\ohm' )} \pm1\% $$
$$ R_2 = \py{r'\SI{%s}{%s}' % (signif(R_2_nom/1000, 3), r'\kilo\ohm' )} \pm1\% $$
$$ V_{out,\ min.} \approx \py{r'\SI{%s}{%s}' % (signif(np.min(V_out), 3), r'\volt')} $$

\begin{figure}[!ht]
    \centering
    \input{figures/pgf/psu_v_out_monte_carlo.pgf}
    \input{figures/pgf/psu_v_out_monte_carlo_cum.pgf}
    \caption{Power Supply Output Voltage}
\end{figure}

\subsubsection{Diode}
The switching diode used must have a fast recovery time and support a larger reverse-voltage than that of the TPS61170 (\SI{40}{\volt}). A robust component for this application is the Diodes Incorporated DFLS240L-7 in a PowerDI-123 package, which meets the requirements, has a low forward-voltage of around \SI{20}{\milli\volt} at low currents, and is a standard part with many alternates available. The Diodes Incorporated DFLS260L-7, also in a PowerDI-123 package, is promoted as a robust alternate from the same family with a higher voltage rating.

% TODO: Diode Analysis
$$ I_D = I_S\left(e^{\frac{q_{e^-}V_D}{nk_BT}} - 1 \right) $$
$$ V_D = \frac{nk_BT}{q_{e^-}}  \ln\left(\frac{I_D}{I_S} + 1 \right) $$

\subsubsection{Input/Output Capacitors}
Input and output capacitors are selected based on the upper limits of the datasheet recommendations and are chosen to be \SI{12}{\micro\farad} MLCC-type surface-mount capacitors. In order to minimize derating, a medium-voltage and physically large capacitor is selected with a voltage rating of greater than \SI{50}{\volt}.

$$ C_{out, min.} = \py{r'\SI{%s}{%s}' % (signif(C_out_value*1e6, 3), r'\micro\farad')} $$

\begin{figure}[!ht]
    \centering
    \input{figures/pgf/psu_c_out_monte_carlo.pgf}
    \input{figures/pgf/psu_c_out_monte_carlo_cum.pgf}
    \caption{Power Supply Output Capacitor Size}
\end{figure}

\subsubsection{SEPIC Coupling Capacitor}
The SEPIC coupling capacitor is chosen to be \SI{1}{\micro\farad}. Similar to the output capacitors, to minimize derating due to applied DC bias voltage, a medium-voltage and physically large capacitor is selected with a voltage rating of greater than \SI{50}{\volt}. The figure below suggests that a \SI{500}{\nano\farad} capacitor would be sufficient, but the datasheet recommends \SI{1}{\micro\farad} and there are already other \SI{1}{\micro\farad} capacitors used in the design.

$$ C_{s, min.} = \py{r'\SI{%s}{%s}' % (signif(C_s_value*1e6, 3), r'\micro\farad')} $$

\begin{figure}[!ht]
    \centering
    \input{figures/pgf/psu_c_s_monte_carlo.pgf}
    \input{figures/pgf/psu_c_s_monte_carlo_cum.pgf}
    \caption{Power Supply SEPIC Coupling Capacitor Size}
\end{figure}

\subsubsection{Compensation Network}
% TODO Tune with first board spin
The compensation network for the DC/DC converter shall be tuned with the first prototypes.

\subsubsection{Linear Regulator}
% TODO: Document design of regulator and look into feedback network - is there a more optimal size? Low resistance values will reduce efficiency
The generic 1117-style three-terminal regulator was chosen as the post-regulator for the analog voltage rail for its low dropout voltage, low cost, and wide availability and compatibility with offerings from several manufacturers. The BOM specifies an Onsemi part number but any \SI{1}{\ampere} 1117-style regulator should be compatible.

The output voltage is determined via the typical three-terminal voltage regulator equation, shown below.

$$ V_{out} = V_{ref}\left(1+\frac{R_2}{R_1}\right) + I_{adj}R_2 $$

Setting $R_1=\SI{120}{\ohm}$ sets the current through the feedback network to \SI{10}{\milli\ampere}, which is nominally twice the required current to maintain regulation. With $R_1$ defined, the other parameters are determined from the datasheet and a value for $R_2$ is obtained.

\begin{pycode}
V_out_nom = 12
R_1 = np.zeros(ntrials)
V_ref = np.zeros(ntrials)
I_adj = np.zeros(ntrials)
R_2 = np.zeros(ntrials)
V_out = np.zeros(ntrials)

i = 0
while i < ntrials: 
    R_1[i] = rng.triangular(1000*0.99, 1000, 1000*1.01)
    V_ref[i] = rng.triangular(1.25*0.99, 1.25, 1.25*1.01)
    I_adj[i] = rng.triangular(0.99*52e-6, 52e-6, 1.01*52e-6)
    R_2_nom = find_closest_e_series_number(
        (V_out_nom-V_ref[i]) / (I_adj[i]+V_ref[i]/R_1[i]),
        tolerance
        )
    R_2[i] = rng.triangular(0.99*R_2_nom, R_2_nom, 1.01*R_2_nom)
    V_out[i] = V_ref[i]*(1+(R_2[i]/R_1[i])) + I_adj[i]*R_2[i]
    i += 1

fig, ax = plt.subplots(1, 1)
ax.hist(V_out, bins='auto', label=r"$V_{out}=\SI{12}{\volt}_{nom.}$")
ax.xaxis.set_major_formatter(eng_format(r'\unit{\volt}'))
ax.set_xlabel(r'Post-Regulator Output Voltage')
ax.set_ylabel(r'Count $\left(1\right)$')
save_pythontex_figure(fig, 'analog_supply_post_reg_output_voltage')
\end{pycode}

\begin{figure}[!ht]
    \centering
    \input{figures/pgf/analog_supply_post_reg_output_voltage.pgf}
    \caption{Analog Supply Post-Regulator Output Voltage}
\end{figure}

\subsection{Low-Voltage Supply}
\subsubsection{Linear Regulator}

\begin{pycode}
V_out_nom = 3.3
R_1 = np.zeros(ntrials)
V_ref = np.zeros(ntrials)
I_adj = np.zeros(ntrials)
R_2 = np.zeros(ntrials)
V_out = np.zeros(ntrials)

i = 0
while i < ntrials: 
    R_1[i] = rng.triangular(120*0.99, 120, 120*1.01)
    V_ref[i] = rng.triangular(1.25*0.99, 1.25, 1.25*1.01)
    I_adj[i] = rng.triangular(0.99*52e-6, 52e-6, 1.01*52e-6)
    R_2_nom = find_closest_e_series_number(
        (V_out_nom-V_ref[i]) / (I_adj[i]+V_ref[i]/R_1[i]),
        tolerance
        )
    R_2[i] = rng.triangular(0.99*R_2_nom, R_2_nom, 1.01*R_2_nom)
    V_out[i] = V_ref[i]*(1+(R_2[i]/R_1[i])) + I_adj[i]*R_2[i]
    i += 1

fig, ax = plt.subplots(1, 1)
ax.hist(V_out, bins='auto', label=r"$V_{out}=\SI{12}{\volt}_{nom.}$")
ax.xaxis.set_major_formatter(eng_format(r'\unit{\volt}'))
ax.set_xlabel(r'Digital Supply Output Voltage')
ax.set_ylabel(r'Count $\left(1\right)$')
ax.legend(loc='upper left')
save_pythontex_figure(fig, '3v3_reg_output_voltage')
\end{pycode}

The low voltage supply is provided by a linear voltage regulator for simplicity. In the future, a second switching converter may be designed to replace it, in the interest of efficiency. To consolidate the bill of materials the same regulator is used as for the analog supply. The output voltage is determined by the same relationship as that shown above. By letting $V_{out}=\SI{3.3}{\volt}$, $R_1=\SI{120}{\ohm}$, and $I_{adj}=\SI{120}{\micro\ampere}$, the above relationship yields approximately $R_2=\py{r'\SI{%s}{\ohm}' % (round(R_2_nom))}$. The low-voltage supply can be run at lower voltages. A study should be performed to determine how low - \SI{1.8}{\volt} is supported by all digital circuits in the system.


\begin{figure}[!ht]
    \centering
    \input{figures/pgf/3v3_reg_output_voltage.pgf}
    \caption{\SI{3.3}{\volt} Regulator Output Voltage}
\end{figure}

\section{Effects Interface}

The effects interface connects three external effects modules through two TMUX4053 analog multiplexers. The TMUX4053 is an upgraded version of the standard 4053 CMOS multiplexer with a higher voltage rating and improved impedance parameters. The signals are sent to the external modules and return via the same connectors, then are routed through the multiplexer circuit to the next effects module or to the main output. 

\subsection{Switching}

The TMUX4053 was selected for two main reasons. Primarily, it supports the 12V supply with comfortable margin. As a second reason, the TMUX4053 is offered in a compact SMD package which improves reliability. The control signals for the multiplexers are generated by the RP2040 microcontroller which polls the footswitches and accordingly manages the switching logic for the multiplexers.

%TODO: Impedance/Attenuation analysis

%TODO: Write truth-table for switches

\subsection{Interface}

%TODO: output/input filtering

\section{Microcontroller}

The Raspberry Pi RP2040 dual-core ARM microcontroller was selected for two primary reasons: its extremely good cost per performance ratio despite being much more powerful than this application demands, and for the excellent documentation provided by the manufacturer.

In this design, the microcontroller performs the functions listed below, along with some other minor tasks.

\begin{itemize}
    \item Manage audio switching logic and control analog switches
    \item Monitor footswitch status
    \item Control indicator LEDs
    \item USB 2.0 controller
\end{itemize}

\subsubsection{Power}

The microcontroller has a peak current draw of approximately \SI{100}{\milli\ampere} from the \SI{3.3}{\volt} rail, yielding a power consumption of approximately \SI{330}{\milli\watt}. The RP2040's internal low-voltage levels are generated using the integrated LDO which uses two external capacitors (C411 and C413), shared between pin 45 and pin 23 of the IC. The remaining external capacitors are used as decoupling capacitors for the \SI{3.3}{\volt} rail.

\subsection{Memory}

Any standard AT25xxx memory may be used for this design, assuming it has the correct package and memory layout. A DFN package was selected for mechanical reliability and for being widely available. The design specifies the maximum possible memory of \SI{128}{\mega\bit} to ease the software development process, but may be reduced in the future as an exercise in cost reduction.

\subsection{Clocks and Timing}

The manufacturer's recommend crystal, the ABM8-272-T3, was selected to generate the clock signals. The crystal has an SMD package and is widely available. If unavailable, a new crystal will have to be selected and rigorously tested.

\subsection{GPIO}



\section{Peripherals}

\subsection{Overview}

\subsection{Footswitches}

\subsection{USB}

\end{document}
