\documentclass[12pt]{report}

% Fonts
\usepackage[stixtwo]{fontsetup}
\setsansfont
    [Ligatures=TeX,
    UprightFont={* Light},
    ItalicFont={* Light Italic},
    BoldFont={* SemiBold},
    BoldItalicFont={* SemiBold Italic},
    Scale=MatchLowercase]
    {Iosevka Aile}
\setmonofont
    [Ligatures=TeX,
    Scale=MatchLowercase]
    {Iosevka Term}

% Mathematics
\usepackage{mathtools} % Mathematics typesetting
\usepackage{siunitx} % Handy typesetting of units
\sisetup{
   detect-family,
   detect-inline-family=math,
}

% Localization
\usepackage[USenglish]{babel} % American English localization
\usepackage[letterpaper, margin=1in]{geometry} % Page formatting
\usepackage[text = DRAFT]{draftwatermark} % Watermarks

% Headers
\usepackage[nocheck]{fancyhdr}
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0pt}
\fancyhead[L]{\textsf{BASEBOARD DESIGN REPORT}}
\fancyhead[R]{\textsf{VERSION 0.1}}
\pagestyle{fancy}

% Table of Contents Formatting
\usepackage{titletoc}

% Chapter and Section Title Formatting
\usepackage{titlesec}
\titleformat{\chapter}
    {\sffamily}
    {\LARGE\textbf{\thechapter}}{1ex}{\LARGE}
\titleformat{\section}
    {\sffamily}
    {\Large\thesection}{1ex}{\Large}
\titleformat{\subsection}
    {\sffamily}
    {\large\thesubsection}{1ex}{\large}
\titleformat{\subsubsection}
    {\sffamily}
    {\normalsize\thesubsubsection}{1ex}{}

\newenvironment{revisionhistory}
    {\setcounter{secnumdepth}{0}}
    {\setcounter{secnumdepth}{2}}

% Command Patching
\usepackage{etoolbox}
\patchcmd{\chapter}{\thispagestyle{plain}}{\thispagestyle{fancy}}{}{}

% Tables
\usepackage{tabularray} % Tables and Arrays

% Hyperlinks
\usepackage{hyperref} % Hyperlinks

% Reformat Enumerated Lists - primarily for specifications
\usepackage{enumitem}
    \setlist[enumerate]{label*=\arabic*.,ref=\arabic*}

% Code Execution and Typesetting
\usepackage[pygopt={style=algol, texcomments=true, mathescape=true}]{pythontex}
% TODO: Add csquotes for proper quotes in verbatim code

% Graphics
\usepackage{graphicx} % External graphics
\graphicspath{{figures/}{./}} % Set base path for graphics
\usepackage{blox} % System block diagrams
\usepackage{tikz-timing} % Timing diagram graphics
\usepackage[siunitx]{circuitikz} % Electrical circuit graphics
\ctikzloadstyle{romano} % Better styling for CircuiTikz
\tikzset{romano circuit style} % Apply the style

% Define Python Context
\makeatletter
\newcommand*\fsize{\dimexpr\f@size pt\relax}
\makeatother
\setpythontexcontext{
    textwidth=\the\textwidth,
    textheight=\the\textheight,
    normalsize=\the\fsize
}

% Python Environment Setup
\begin{pycode}

import numpy as np # Python numerical computing library

from cycler import cycler # Property cycler utilities
from matplotlib import pyplot as plt # Pyplot API
from matplotlib import rcParams as rc # Matplotlib plot styling
from matplotlib.ticker import EngFormatter # Plot tick formatting

# Convert from points to inches
text_width = float(pytex.context['textwidth'][:-2]) / 72.27
text_height = float(pytex.context['textheight'][:-2]) / 72.27

# Determine font sizes based on normalsize
# TODO: Can each fontsize be defined programmatically?
normal_size = float(pytex.context['normalsize'][:-2])
if normal_size == 10:
    tiny = 5
    script_size = 7
    footnote_size = 8
    small = 9
    large = 12
    llarge = 14.4
    lllarge = 17.28
    huge = 20.74
    hhuge = 24.88
elif normal_size == 11:
    tiny = 6
    script_size = 8
    footnote_size = 9
    small = 10
    large = 12
    llarge = 14.4
    lllarge = 17.28
    huge = 20.74
    hhuge = 24.88
elif normal_size == 12:
    tiny = 6
    script_size = 8
    footnote_size = 10
    small = 11
    large = 14.4
    llarge = 17.28
    lllarge = 20.74
    huge = 24.88
    hhuge = 24.88

golden_ratio = ( 1 + np.sqrt(5) ) / 2
num_plot_styles = 4 # number of colors for plotting

# Initialize lists for plot colors and styles
plot_colors = []
line_styles = []

cmap = plt.get_cmap('gray') # Select colormap

for i in range(num_plot_styles): # Populate the color and style lists
    plot_colors.append(cmap(1.0 * i/num_plot_styles))
    line_styles.append((0, (i+1, i)))

# Define the main cycler with the two component lists 
style_cycler = cycler(color=plot_colors, linestyle=line_styles)

# Document-wide Matplotlib Configuration
rc.update({
        'backend': 'pgf',
        'lines.linewidth': 0.125*footnote_size,
        'font.family': 'serif',
        'font.size': footnote_size,
        'text.usetex': True,
        'legend.fontsize': footnote_size,
        'axes.formatter.use_locale': True,
        'axes.prop_cycle': style_cycler,
        'axes.labelsize': footnote_size,
        'xtick.direction': 'in',
        'xtick.top': True,
        'xtick.bottom': True,
        'xtick.minor.visible': True,
        'ytick.direction': 'in',
        'ytick.left': True,
        'ytick.right': True,
        'ytick.minor.visible': True,
        'legend.fancybox': False,
        'figure.figsize': (text_width, text_width/golden_ratio),
        'figure.dpi': 600,
	'figure.constrained_layout.use': True,
        'savefig.format': 'pdf',
        'savefig.transparent': True,
        'pgf.rcfonts': False,
	'pgf.preamble': '\n'.join([
                r'\usepackage[stixtwo]{fontsetup}',
                r'\usepackage{siunitx}',
		r'\usepackage[USenglish]{babel}',
	]),
        'pgf.texsystem': 'lualatex', # default is xetex
})

def eng_format(arg: str):
    return EngFormatter(unit=arg, sep=None)
\end{pycode}

\begin{document}

\title{\textsf{\textbf{Baseboard\\Design Report}}}
\author{\textsf{Alessandro Rizzoni}}
\date{\textsf{\today}}

\maketitle

\tableofcontents

\pagebreak

\vspace*{\fill}
\begin{center}
	This page intentionally left blank.
\end{center}
\vspace*{\fill}

\pagebreak

\begin{revisionhistory}

\section{Revision History}

\end{revisionhistory}

\pagebreak

\vspace*{\fill}
\begin{center}
	This page intentionally left blank.
\end{center}
\vspace*{\fill}

\pagebreak

\chapter{Introduction}
The baseboard module contains all the signal and power IO for the effects module. Input voltage of \qty{9}{\volt} DC is regulated to \pm 9V to drive an analog switch and the effects board and to \qty{3.3}{\volt} to drive the LED indicators and footswitches. A \qty{16}{\bit} microcontroller manages the switching logic, interfaces with peripherals, and supervises the power supply circuit. The audio input and output are routed to the effects board via the switching circuitry through a flat flex cable.

\chapter{Specifications}
\begin{enumerate}
	\item Power
	      \begin{pycode}
min_freq = 0.3
max_freq = 100E6
frequency = np.logspace(np.log10(min_freq), np.log10(max_freq), 30000, base=10)

noise_spec_9V = []
noise_spec_LV = []
corner_freq_9V = 100
corner_freq_LV = 100

for freq in frequency:
    if freq < corner_freq_9V:
        noise_spec_9V.append(-40)
    else:
        noise_spec_9V.append(-60)

    if freq < corner_freq_LV:
        noise_spec_LV.append(-30)
    else:
        noise_spec_LV.append(-55)

fig, ax = plt.subplots(1, 1)
ax.plot(frequency, noise_spec_9V, label=r'\pm 9V Supply')
ax.plot(frequency, noise_spec_LV, label=r'+3.3V Supply')
ax.set_xscale('log')
ax.xaxis.set_major_formatter(eng_format(r'\unit{\hertz}'))
ax.yaxis.set_major_formatter(r'\unit{\deci\bel\volt}')
ax.set_ylim(-100, 0)
ax.legend()
fig.savefig('psu_noiselim.pdf')
	      \end{pycode}
	      \begin{enumerate}
		      \item The Baseboard shall provide a \qty{\pm 9}{\volt} \pm 1\% power supply capable of sourcing \pm \qty{200}{\milli\ampere} peak to the audio effects board
		      \item The Baseboard shall provide low-voltage power circuitry capable of operation from \qty{1.2}{\volt} \pm 1\% to \qty{5}{\volt} \pm 1\%
		      \item The Baseboard shall be capable of sourcing \qty{150}{\milli\ampere} peak to drive local peripherals
		      \item Noise from any power supply must be below \qty{-40}{\deci\bel\volt} at all frequencies and below \qty{-60}{\deci\bel\volt} above \qty{100}{\hertz}
		            \begin{figure}[h!]
			            \centering
			            \includegraphics{psu_noiselim.pdf}
			            \caption{Power Supply Output Noise Limit}
		            \end{figure}
	      \end{enumerate}
	      \item{Input/Output}
	      \begin{enumerate}
		      \item The Baseboard shall route the audio signal to the baseboard while providing a true bypass path directly to the output
		      \item The Baseboard shall provide input impedance of \qty{1}{\mega\ohm} \pm 1\% and output impedance of \qty{50}{\kilo\ohm} \pm 1\%
		      \item Input Filter
		      \item Output Filter
	      \end{enumerate}
	      \item{Switching}
	      \begin{enumerate}
		      \item The audio signal shall be switched using high quality analog switches to maximize durability and signal integrity
		      \item The switches shall have an input impedance of no greater than \qty{500}{\ohm} to minimize impedance matching losses
	      \end{enumerate}
\end{enumerate}

\chapter{System Architecture}

\section{Power Supply Design}

\subsection{Overview}

\begin{pyblock}
V_POS = 12
V_NEG = -12
V_IN = 8.55
V_FB1 = 0.8
V_FB2 = 0.8
V_REF = 1.6
I_OUT1 = 200E-3
I_OUT2 = -200E-3
R_FT1 = 1E6
R_FT2 = 1E6
R_FB1 = R_FT1 / ( (V_POS / V_FB1) - 1 )
R_FB2 = R_FT2 * (V_REF - V_FB2) / (V_FB2 - V_NEG)
print(f"R_FT1 = {R_FT1} 立")
print(f"R_FB1 = {R_FB1} 立")
print(f"R_FT2 = {R_FT2} 立")
print(f"R_FB2 = {R_FB2} 立")
\end{pyblock}

\printpythontex

\subsection{Feedback Resistors}

To select the appropriate feedback resistors, the following relationships were taken from the datasheet to compute the correct values. The positive output for the boost regulator can be set using the relationship

$$ V_{POS} = V_{FB1} \left( 1 + \frac{R_{FT1}}{R_{FB1}} \right) $$

where $V_{POS}$ is the positive output voltage, $V_{FB1}$ is the $FB1$ reference voltage, $R_{FT1}$ is the feedback resistor from $V_{POS}$ to $FB1$, and $R_{FB1}$ is the feedback resistor from $FB1$ to $AGND$.

The negative output for the inverting regulator can be set using the relationship

$$ V_{NEG} = V_{FB2} - \frac{R_{FT2}}{R_{FB2}} \left( V_{REF} - V_{FB2} \right) $$

where $V_{NEG}$ is the negative output voltage, $V_{FB2}$ is the $FB2$ reference voltage, $R_{FT2}$ is the feedback resistor from $V_{NEG}$ to $FB2$, $R_{FB2}$ is the feedback resistor from $FB2$ to $V_{REF}$, and $V_{REF}$ is the $V_{REF}$ pin reference voltage.

In order to have the correct margin to allow for the linear regulator drop-out voltage, output voltages of $\pm12V$ were selected, yielding the following values for the feedback resistors as taken from the table in the datasheet.

$$R_{FT1} = 1.4M\Omega$$
$$R_{FB1} = 100k\Omega$$
$$R_{FT2} = 1.15M\Omega$$
$$R_{FB2} = 71.5k\Omega$$

The low-noise precision resistors chosen for the design do not support values above $1M\Omega$, so these ratios must be reconfigured to have the largest value resistor be $1M\Omega$. The relationships above can be rewritten to solve for the other resistor value.

$$ R_{FB1} = \frac{R_{FT1}}{\frac{V_{POS}}{V_{FB1}}-1} $$

$$ R_{FB2} = R_{FT2}\frac{V_{REF} - V_{FB2}}{V_{FB2}-V_{NEG}} $$

\subsection{Output Capacitors}

The capacitor dielectric is chosen to be X5R or X7R to provide adequate temperature and DC bias characteristics. The worst-case capacitance considering temperature variation, tolerance, and voltage can be found using the following equation from the datasheet

$$ C_{EFF} = C_{NOM} \left(1 - \delta_{TEMP} \right) \left(1 - \delta_{BIAS} \right) \left(1 - \delta_{TOL} \right)$$

where $C_{EFF}$ is the effective capacitance at the specified operating voltage, $C_{NOM}$ is the nominal datasheet capacitance, $\delta_{TEMP}$ is the worst-case capacitor temperature derating coefficient, $\delta_{BIAS}$ is the DC bias derating at the specified output voltage, and $\delta_{TOL}$ is the worst-case component tolerance.

The datasheet suggests a value of $10\mu F$ as a compromise between performance and size - a value of $22\mu F$ was selected to provide additional filtering without compromising performance by a large amount. This value will provide extremely comfortable margins at the worst-case values determined above, and will provide better filtering than the recommended value with better response time. Thus,

$$C_{OUT_+} = C_{OUT_-} = 22\mu F$$

\begin{pyblock}
C_OUT = 20E-6
D_TEMP = 0.014
D_BIAS = 0.120
D_TOL = 0.200
C_OUT_ESR = 2.5E-3
C_OUT_EFF = C_OUT * ( 1 - D_TEMP ) * ( 1 - D_BIAS ) * ( 1 - D_TOL )
print(r'C_OUT_EFF = ' + f'{C_OUT_EFF}')
\end{pyblock}

\subsection{Input Capacitors}

Larger value input capacitors reduce input voltage ripple and improve transient response of the system. Component placement should be optimized to minimize supply noise by placing the input capacitors as close as possible to the power input pins. For stability, and effective capacitance of at least $10\mu F$ is required, with a minimum of $5.6\mu F$ required for the PV\_IN1 and PV\_IN2 pins and $3.3\mu F$ required for the PV\_INSYS pin. To minimize the number of componentes in the BOM, the same $22\mu F$ capacitor will be used to decouple the power input pins - one for PV\_IN1 and PV\_IN2 and another for PV\_INSYS.

\begin{pyblock}
C_PV_IN = 22E-6
C_PV_INSYS = 22E-6
\end{pyblock}

\subsection{$V_{REG}$ Capacitor}

The datasheet requires a $1.0\mu F$ ceramic capacitor between the VREG pin and AGND.

\begin{pyblock}
C_VREG = 1E-6
\end{pyblock}

\subsection{$V_{REF}$ Capacitor}

The datasheet requires a $1.0\mu F$ ceramic capacitor between the VREF pin and AGND.

\begin{pyblock}
C_VREG = 1E-6
\end{pyblock}

\subsection{Soft Start Resistor}

Soft start is not a required feature, but it can be implemented and the resistor DNP'ed to save on cost if desired. The plot below shows the relationship between the soft start time and the value of the timing resistor. A resistor value of $71.5k\Omega$ yields a soft start time of approximately $29ms$ and is already being used in the circuit as $R_{FB2}$.

\begin{pyblock}

fig, ax = plt.subplots(1, 1)
R_SOFT_START = np.linspace(50E3, 268E3, 800)
t_SOFT_START = 38.4E-3 - 1.28E-7 * R_SOFT_START

ax.plot(R_SOFT_START, t_SOFT_START, label='Soft Start Resistor Values')

R_SOFT_START = 71.5E3
t_SOFT_START = 38.4E-3 - 1.28E-7 * R_SOFT_START

ax.plot(R_SOFT_START, t_SOFT_START, label='Selected Resistance')

ax.yaxis.set_major_formatter(eng_format(r'\unit{\second}'))
ax.xaxis.set_major_formatter(r'\unit{\ohm}')

ax.legend()
fig.savefig('psu_softstart.pdf')

\end{pyblock}

\begin{figure}[h!]
	\centering
	\includegraphics{psu_softstart.pdf}
	\caption{Soft-Start Resistor Chart}
\end{figure}

\subsection{Diodes}

A low forward voltage Schottky diode with less than $40pF$ junction capacitance is recommended for D1 and D2. The selected diode, the Diodes Incorporated DFLS240L-7, has a typical forward voltage $V_{DF} = 450mV$ and a typical junction capacitance of $90pF$. This capacitance is higher than recommended, but the efficiency losses will be minimal.

\begin{pyblock}
V_DF = 450E-3
C_D = 90E-12
\end{pyblock}

\subsection{Boost Regulator Inductor}

The datasheet recommends an inductor value between $1\mu H$ and $22\mu H$ as a good compromise between inductor current ripple and efficiency. The inductor ripple current in the worst-case, the continuous conduction mode, can be calculated. The switch duty cycle, $DUTY_1$, can be found from the relationship below.

$$ DUTY_1 = \left( \frac{V_{POS} - V_{IN} + V_{DF}}{V_{POS} + V_{DF}} \right)$$

The DC input current during the constant current mode can be found from the equation below.

$$ I_{IN} = \frac{I_{OUT1}}{1 - DUTY_1}$$

Using the duty cycle and switching frequency, the switch on-time can be obtained as follows. The switching frequency is chosen here to be either $1.2MHz$ or $2.4MHz$.

$$ t_{ON1} = \frac{DUTY_1}{f_{SW}} $$

Finally, the on time is then used to find the inductor size as a function of inductor ripple current at steady-state.

$$ L1 = \frac{V_{IN}t_{ON1}}{\Delta I_{L1}} $$

Assuming inductor ripple current of 30\% the maximum DC input current yields the following expression.

$$ L1 = \frac{V_{IN}t_{ON1}\left(1-DUTY_1\right)}{0.3I_{OUT_1}} $$

To ensure stability, the minimum inductance is given by the below equation from the datasheet.

$$ L1_{MIN} = V_{IN} \left( \frac{0.27}{1-DUTY_1} - 0.33\right) \left[ \mu H\right]$$

\begin{pyblock}
f_SW = 2.4E6
DUTY_1 = ( V_POS - V_IN + V_DF ) / (V_POS + V_DF)
I_IN = I_OUT1 / ( 1 - DUTY_1 )
T_ON1 = DUTY_1 / f_SW
L1 = V_IN * T_ON1 * ( 1 - DUTY_1) / ( 0.3 * I_OUT1)
L1_MIN = 1E-6 * V_IN * ( ( 0.27 / (1 - DUTY_1)) - 0.33)
print("L1 =", L1)
print("L1_MIN =", L1_MIN)
\end{pyblock}

\printpythontex

\subsection{Inverting Regulator Inductor}

Similarly, the inductor value for the inverting regulator's inductor can be derived. Again starting with the duty cycle, $DUTY_2$ we obtain the following expression.

$$ DUTY_2 = \left( \frac{|V_{NEG}| + V_{DF}}{V_{IN} + |V_{NEG}| + V_{DF}} \right) $$

The DC current in the constant current mode can then be found as a function of the duty cycle.

$$ I_{L2} = \frac{I_{OUT2}}{1 - DUTY_2} $$

The switch on time is also expressed as a function of the duty cycle.

$$ t_{ON2} = \frac{DUTY_2}{f_{SW}} $$

And again, the inductance value can be obtained from the on time and the inductor ripple current.

$$ L2 = \frac{V_{IN}t_{ON2}}{\Delta I_{L2}} $$

Again assuming a ripple current of $30\%$ the  maximum DC current will allow the expression to be solved as follows.

$$ L2 = \frac{V_{IN}t_{ON2}\left( 1 - DUTY_2\right)}{0.3I_{OUT2}} $$

To ensure stability, the $L2$ inductor value must be greater than the minimum inductance obtained below.

$$ L2_{MIN} = V_{IN}\left( \frac{0.27}{1 - DUTY_2} - 0.33\right) \left[ \mu H\right]$$

\begin{pyblock}
DUTY_2 = ( np.abs(V_NEG) + V_DF ) / ( V_IN + np.abs(V_NEG) + V_DF )
I_L2 = I_OUT2 / ( 1 - DUTY_2 )
t_ON2 = DUTY_2 / f_SW
L2 = V_IN * t_ON2 * ( 1 - DUTY_2 ) / ( 0.3 * np.abs(I_OUT2) )
L2_MIN = 1E-6 * V_IN * ( ( 0.27 / ( 1 - DUTY_2)) - 0.33 )
print("L2 =", L2)
print("L2_MIN =", L2_MIN)
\end{pyblock}

\printpythontex

\subsection{Boost Regulator Compensation}

The ADP5070 allows for external loop compensation to optimize the dynamics for a given application. The design of the compensation network for the boost regulator is performed following the datasheet recommendations as follows.

\begin{figure}[h!]
	\centering
	\begin{circuitikz}[]
		\draw (0, 0) node[above]{FB1} to[short, o-] ++(1,0)
		node[op amp, anchor=-](OA){$g_{M1}$}
		(OA.+) -- ++(-1,0) coordinate(REF)
		to[short, o-] node[above]{REF} ++(0,0)
		(OA.out) -- ++(1,0) coordinate(VOUT1)
		to[short, *-] node[above]{COMP1} ++(2,0)
		(VOUT1) to[R=$R_{C1}$] node[]{} ++(0,-2) coordinate(R1)
		(R1) to[C=$C_{C1}$] node[ground]{} ++(0,-1)
		(VOUT1) -- ++(2,0) coordinate(VOUT2)
		to[C=$C_{B1}$] node[]{} ++(0,-2.8) coordinate(GND)
		(GND) to[short] node[ground]{} ++(0,0)
		;
	\end{circuitikz}
	\caption{Boost Regulator Compensation Topology}
\end{figure}

The boost regulator requires compensation such that the crossover frequency occurs below the frequency of the right-half plane zero introduced by the topology of the converter. The zero is can be determined as shown below, where $f_{Z1}(RHP)$ is the right half plane zero frequency and $R_{LOAD1}$ is the equivalent load resistance.

$$ f_{Z1}(RHP) = \frac{R_{LOAD1}\left( 1 - DUTY_1 \right)^2}{2\pi L1} $$

The datasheet recommends that the regulator crossover frequency be less than or equal to one-tenth the right half plane zero frequency. The boost regulator loop gain is

$$ A_{VL1} = \frac{V_{FB1}V_{IN}}{V_{POS}}G_{M1}|R_{OUT1}||Z_{COMP1}|G_{CS1}|Z_{OUT1}| $$

where $A_{VL1}$ is the loop gain, $V_{FB1}$ is the feedback regulation voltage, $V_{POS}$ is the regulated positive output voltage, $V_{IN}$ is the input voltage, $G_{M1}$ is the error amplifier transconductance gain, $R_{OUT1}$ is the output impedance of the error amplifier and is $33M\Omega$, $Z_{COMP1}$ is the impedance of the series RC network from $COMP_1$ to $AGND$, $G_{CS1}$ is the current sense transconductance gain (the inductor current divided by the voltage at $COMP_1$), which is internally set by the ADP5070 to 6.25 A/V, and finally $Z_{OUT1}$ is the impedance of the load in parallel with the output capacitor.

To solve for the crossover frequency, the equation may be simplified to

$$ A_{VL1} = \frac{V_{FB1}V_{IN}}{V_{POS}}\frac{G_{M1}R_{C1}G_{CS1}}{2\pi f_{C1}C_{OUT1}} = 1 $$

where $f_{C1}$ is the crossover frequency.

To solve for $R_{C1}$, the datasheet provides the following equation, where $G_{M1} = 6.25 A/V$.

$$ R_{C1} = \frac{2\pi f_{C1}C_{OUT1}V_{POS}^2}{V_{FB1}V_{IN}G_{M1}G_{CS1}} $$

From the datasheet, this equation can be simplified.

$$ R_{C1} = \frac{4188 f_{C1}C_{OUT1}V_{POS}^2}{V_{IN}} $$

For best accuracy, the datasheet recommends using the effective capacitance of the output capacitor under DC bias conditions that will be seen in operation.

Once the compensation resistor has been found, the zero can be set to one-fourth the crossover frequency, per the datasheet's recommendation.

$$ C_{C1} = \frac{2}{\pi f_{C1}R_{C1}} $$

The parallel capacitor is then chosen to cancel the zero introduced by the output capacitor ESR.

$$ C_{B1} = \frac{R_{ESR} C_{OUT1}}{R_{C1}} $$

From the datasheet, for most applications, $R_{C1}$ must be within the range of $1 k\Omega$ to $200 k\Omega$, and $C_{C1}$ must be within the range of $1 nF$ to $68 nF$.

\begin{pyblock}
R_LOAD1 = V_POS / I_OUT1
f_Z1_RHP = ( R_LOAD1 * ( 1 - DUTY_1 )**2 ) / ( 2*np.pi * L1 )
f_C1 = f_Z1_RHP * 95E-3
V_FB1 = V_POS * R_FB1 / ( R_FB1 + R_FT1 )
G_M1 = 300E-6 # from datasheet
G_CS1 = 6.25 # from datasheet
R_C1 = ( 2*np.pi * f_C1 * C_OUT_EFF * V_POS**2 ) / ( V_FB1 * V_IN * G_M1 * G_CS1 )
C_C1 = 2 / ( np.pi * f_C1 * R_C1 )
C_B1 = C_OUT_ESR * C_OUT / R_C1
print("R_C1 =", R_C1)
print("C_C1 =", C_C1)
print("C_B1 =", C_B1)
\end{pyblock}

\printpythontex

\subsection{Inverting Regulator Compensation}

The design of the inverting regulator compensation network is similar to that of the boost regulator compensation network. For the sake of brevity, the detailed explanation has been omitted, but the process is the same as above.

\begin{pyblock}
R_LOAD2 = V_NEG / I_OUT2
f_Z2_RHP = ( R_LOAD2 * ( 1 - DUTY_2 )**2 ) / ( 2*np.pi * L2 * DUTY_2 )
f_C2 = f_Z2_RHP * 95E-3
V_FB2 = V_NEG * R_FT2 / ( R_FB2 + R_FT2 )
G_M2 = 300E-6 # from datasheet
G_CS2 = 6.25 # from datasheet
R_C2 = ( 2*np.pi * f_C2 * C_OUT_EFF * np.abs(V_NEG) * ( V_IN + ( 2 * np.abs(V_NEG) ) ) )
R_C2 = R_C2 / ( np.abs(V_FB2) * V_IN * G_M2 * G_CS2 )
C_C2 = 2 / ( np.pi * f_C2 * R_C2 )
C_B2 = C_OUT_ESR * C_OUT / R_C2
print("R_C2 =", R_C2)
print("C_C2 =", C_C2)
print("C_B2 =", C_B2)
\end{pyblock}

\printpythontex

\end{document}
